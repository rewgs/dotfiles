# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ about this file                                                            ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# .zshrc is for interactive shells. You set options for the interactive shell there with the setopt 
# and unsetopt commands. You can also load shell modules, set your history options, change your 
# prompt, set up zle and completion, et cetera. You also set any variables that are only used in the 
# interactive shell (e.g. $LS_COLORS).


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ basic interactive shell settings                                           ║
# ╚════════════════════════════════════════════════════════════════════════════╝


LS_COLORS="ow=01;93;40:ln=00;35;40:ex=00;31;40:*.mp3=00;32;40:*.wav=00;32;40:*.aif=00;32;40:*.aiff=00;32;40"
export LS_COLORS




# configures Homebrew autocomplete in zsh; must be done before sourcing oh-my-zsh
if [[ $(uname) == "Darwin" ]] && [[ $(arch) == "arm64" ]]; then
    eval $(/opt/homebrew/bin/brew shellenv)
    FPATH="$(brew --prefix)/share/zsh/site-functions:${FPATH}"
    autoload -Uz compinit
    compinit
fi


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ oh my zsh                                                                  ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# oh my zsh
ZSH_THEME="robbyrussell"
plugins=(
    docker
    git 
    web-search
)

export ZSH="$HOME/.oh-my-zsh"

source $ZSH/oh-my-zsh.sh


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ misc                                                                       ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# zsh parameter completion for the dotnet CLI
_dotnet_zsh_complete() {
  local completions=("$(dotnet complete "$words")")

  # If the completion list is empty, just continue with filename selection
  if [ -z "$completions" ]
  then
    _arguments '*::arguments: _normal'
    return
  fi

  # This is not a variable assignment, don't remove spaces!
  _values = "${(ps:\n:)completions}"
}

compdef _dotnet_zsh_complete dotnet

# configures the `fuck` command
eval $(thefuck --alias)


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ aliases                                                                    ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

alias es="exec $SHELL && source_shell"

# aws
if [[ $(uname) == "Linux" ]]; then
    alias wasabi="aws s3 --profile wasabi"
    alias wsb="aws s3 --profile wasabi"
    alias s3="aws s3 --profile wasabi"
fi

# zshrc
alias z="$EDITOR $HOME/.zshrc"
alias sz="source $HOME/.zshrc"
alias ss="source_shell"

# common commands and functions
alias c="clear"
if [[ $(uname) == "Darwin" ]] || [[ $(uname) == "Linux" ]]; then
    alias ls=ls_improved
elif [[ $(uname) == "FreeBSD" ]]; then
    alias ls="ls -al"
fi
alias cls=clear_then_ls_improved
alias eh="echo 'You are using $HOST'"
alias mkd="mkdir"
alias mv="mv -i"       # prompts before overwriting already-existing file; TODO: make this take multiple arguments
alias rm=rmv         # aliasing rm to my custom function rmv; TODO: make this take multiple arguments
alias sdo=run_as_sudo

# neovim
alias v="nvim"
alias nvinit="$EDITOR $HOME/.config/nvim/init.lua"

# docker
if [[ $(uname) == "Linux" ]]; then
    alias dcls="docker container ls"
    alias ncst="docker start nextcloud-aio-mastercontainer"
    alias ncsp="docker stop nextcloud-aio-mastercontainer"
    alias rm_all_containers=remove_all_docker_containers
fi

# i3 config
if [[ $(uname) == "Linux" ]]; then
    alias i3c="$EDITOR $HOME/dotfiles/i3/config"
fi

# other editors
alias h="hx"    # helix
alias k="kak"   # kakoune
alias n="nano"  # nano

# broot
# TODO: fix this, not currently working
alias b="br" # invokes broot in power-user mode (br)

# git clients
alias g="git-graph"
alias gg="git-igitt"

# git commands
alias gap=git_add_all_and_push_with_commit_message_arg
alias gp="git pull"
alias gfarp="git fetch --all && git reset --hard && git pull"
alias grm=git_commit_readme

# linode cli
alias linhelp="linode-cli --help"
alias linlinhelp="linode-cli linodes --help"
alias createlinhelp="linode-cli linodes create --help"
alias linls="linode-cli linodes list"

# multipass
if [[ $(uname) == "Darwin" ]]; then
    alias mpls="multipass list"          # lists all multipass VMs
    alias mpsh="multipass shell ubuntu"  # starts and ssh's into main VM
    alias mpst="multipass start ubuntu"  # starts main VM but doesn't connect to it
    alias mpsp="multipass stop ubuntu"   # stops ubuntu VM
    alias snsmpsh="multipass shell sns"
    alias snsmpst="multipass start sns"
    alias snsmpsp="multipass stop sns"
fi

# OrbStack
if [[ $(uname) == "Darwin" ]]; then
    alias archvm="orb -m arch -u rewgs"
    alias ubuntuvm="orb -m ubuntu -u rewgs"
fi

# python
# typically should only be used in an activated venv
alias pipfreeze="pip freeze > requirements.txt"
alias pipinstallreqs="pip install -r requirements.txt"
alias pyserve="python3 -m http.server 8080"

# pyenv
alias av=activate_venv
alias dv="deactivate"
alias nv=create_new_venv
alias nvhb=create_new_venv_v3.9_with_gui_fix_for_mac

# rustup
alias rustbook="rustup docs --book"
alias rustdocs="rustup doc"

# sed
if [[ $(uname) == "Darwin" ]]; then
    alias sed="gsed"
fi

# ssh
alias dlssh=download_file_from_server_as_name

# tailscale
if [[ $(uname) == "Darwin" ]]; then
    alias tailscale="/Applications/Tailscale.app/Contents/MacOS/Tailscale"
fi

alias tshosts=tailscale_get_magic_dns_hostnames

# tar
# if [[ $(uname) == "Linux" ]]; then
#     alias untar="tar -xvzf"
# fi

# tmux
alias t=new_tmux_session_name_optional
alias tls="tmux list-session"
alias ta="tmux attach -t"
alias td="tmux detach"
alias tk="tmux kill-session -t"
alias tq="tmux detach && tmux list-sessions"
alias ts="tmux source-file ~/.tmux.conf"
# TODO: make this a function so it can take arguments -- this is just an idea
# alias tsw="tmux swap-window -s $1 -t $2"
# TODO: make these key commands via iTerm?
# alias tspu="tmux swap-pane -U" # if more than two, goes clockwise
# alias tspd="tmux swap-pane -D" # if more than two, goes counter-clockwise

# yabai/skhd
if [[ $(uname) == "Darwin" ]]; then
    alias yst="brew services start yabai && brew services start skhd"
    alias ysp="brew services stop yabai && brew services stop skhd"
    alias yr="brew services restart yabai && brew services restart skhd"
fi

# xplr
alias x="xplr"

# connections and computers
alias macmini="ssh rewgs@rewgs-mac-mini.local"
alias nas="ssh rewgs@rewgs-nas"

# dotfiles
alias dotfiles="cd $HOME/dotfiles/"
alias dots="cd $HOME/dotfiles/"
alias d="cd $HOME/dotfiles/"
alias dn="cd $HOME/dotfiles/nvim/"

# sns
alias work="cd $HOME/work/"
alias sns="cd $HOME/work/sns/"
alias snsd="cd $HOME/work/sns/development/"
alias snstodo="cd $HOME/work/sns/sns-to-do/ && nvim README.md"

# updates
alias up=update_packages
alias cup=update_packages_and_cargo

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ PATH                                                                       ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# Notes:
# - prepending $PATH: assures that the system looks in this custom path *after* 
#   searching default locations first.
# - appending :$PATH assures that the system looks in this custom path *before* 
#   searching default locations.

# user bin folders
export PATH="$HOME/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/usr/local/bin:$PATH"

# broot
# source $HOME/.config/broot/launcher/bash/br
export PATH="$HOME/.config/broot/launcher/bash:$PATH"

# flutter
export PATH="$HOME/src/flutter/bin:$PATH"

# golang
export GOPATH="$HOME/go"
export PATH="$GOPATH/bin:$PATH"

# jetbrains
if [[ $(uname) == "Darwin" ]]; then
    export PATH="$HOME/Library/Application Support/JetBrains/Toolbox/scripts:$PATH"
fi

# nvm
export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# phpenv
# NOTE:
# - .phpenv is symlinked to ~/src/phpenv; repo cloned from github (https://github.com/phpenv/phpenv)
# - In order to use the `phpenv install` command, one must also install php-build 
#   (https://github.com/php-build/php-build); symlink ~/src/php-build to ~/.phpenv/plugins/php-build
export PATH="$HOME/.phpenv/bin:$PATH"
eval "$(phpenv init -)"

# pyenv
# the following must be in both .zshrc (for interactive login shells) and .zprofile (for non-interactive login shells)
# NOTE: .pyenv is symlinked to ~/src/pyenv, repo cloned from github
if [[ $(uname) == "Darwin" ]]; then
    export PYENV_ROOT="$HOME/.pyenv"
    command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(pyenv init -)"
elif [[ $(uname) == "Linux" ]]; then
    # This checks if the current shell is WSL.
    if [[ $(grep -i Microsoft /proc/version) ]]; then
        # On a machine that has pyenv-win installed on the Windows side, as this messes with the 
        # usual $PYENV_ROOT and tries to run `eval "$(pyenv init -)"` in 
        # `/mnt/c/Users/"$(whoami)"/.pyenv` and thus returns a `bad interpreter` error.
        export PYENV_ROOT="/home/"$(whoami)"/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"
    else 
        # The usual works just fine on non-WSL Linux (this is the same as the "Darwin" branch above).
        export PYENV_ROOT="$HOME/.pyenv"
        command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"
    fi
fi

# reaper
if [[ $(uname) == "Darwin" ]]; then
    alias reaper_exec="/Applications/REAPER.app/Contents/MacOS/REAPER"
    alias REAPER="cd $HOME/Library/Application\ Support/REAPER"
    alias ReaScripts="cd $HOME/Library/Application\ Support/REAPER/Scripts"
    alias rewgsReaScripts="cd $HOME/Library/Application\ Support/REAPER/Scripts/rewgs-reaper-scripts"
elif [[ $(uname) == "Linux" ]]; then
    export PATH="$HOME/opt/REAPER:$PATH"
fi

# rust
export PATH="$HOME/.cargo/bin:$PATH"

if [[ $(uname) == "Darwin" ]]; then
    # homebrew
    export PATH="$PATH:/opt/homebrew/bin"
    export PATH="$PATH:/opt/homebrew/sbin"
    export PATH="$PATH:/opt/homebrew/Cellar"
    
    # nim
    export PATH="$PATH:$HOME/.nimble/bin"
    
    # poetry
    export PATH="$PATH:$HOME/.poetry/bin"
# elif [[ $(uname) == "Linux" ]]; then
# else
#     echo "Unsupported operating system!"
fi

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ zsh functions                                                              ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# This whole bit is weird.
# Basically, this allows me to place my dotfiles dir anywhere, and to easily 
# autoload all my zsh functions, both when running `exec $SHELL` and 
# `source ~/.zshrc`.

if [[ $(uname) == "Darwin" ]]; then
    # Gets the absolute dir path of the file being run.
    # If running `exec $SHELL`, $this_file_name == $(basename $(which zsh));
    # if running `source ~/.zshrc`, $this_file_name == ".zshrc" (if reading 
    # symlink) or "zshrc" (if reading absolute path in dotfiles repo).
    #
    # Uses greadlink in place of readlink so that I can get Linux-like `-f` functionality.
    # If greadlink not installed, run `brew install coreutils`.
    this_file=$(greadlink -f $0)
    this_file_name=$(basename "$this_file")
    this_dir=$(greadlink -f $(dirname "$this_file"))
    this_dir_name=$(basename "$this_dir")

elif [[ $(uname) == "Linux" ]]; then
    this_file=$(greadlink -f $0)
    this_file_name=$(basename "$this_file")
    this_dir=$(greadlink -f $(dirname "$this_file"))
    this_dir_name=$(basename "$this_dir")

else
    echo "Haven't yet dealt with $(uname)."
    echo "TODO: write logic for this!"
fi

echo "This file: $this_file"
echo "This file name: $this_file_name"
echo "This file's parent dir: $this_dir"
echo "This file's parent dir name: $this_dir_name"

# readling `~/.zshrc` symlink
# This shouldn't run, since `(g)readlink -f` is resolving to the absolute path.
# if [[ "$this_file_name" == ".zshrc" ]] && [[ "$this_dir" == "$HOME" ]]; then
if [[ "$this_file_name" == ".zshrc" ]]; then
    echo "\`source\`-ing..."

    # TODO: need to `find` dotfiles dir and then read from there
    echo "Running from $this_dir"

# reading `.../dotfiles/zshrc` absolute path
# elif [[ "$this_file_name" == "zshrc" ]] && [[ "$this_dir_name" == "dotfiles" ]]; then 
elif [[ "$this_file_name" == "zshrc" ]]; then 
    echo "\`source\`-ing..."

    # Sets the directory for user functions
    user_zsh_functions="$this_dir/functions"
    echo "Adding user zsh functions dir $user_zsh_functions to FPATH..."
    FPATH="${user_zsh_functions}:$FPATH"

    # Autoloads all functions in the user functions directory.
    # Don't forget that the functions need the .zsh extension removed 
    # before they're able to be used!
    echo "Autoloading zsh functions..."
    for func in "$user_zsh_functions"/*; do
        echo "\t$(basename "$func")"
        autoload -Uz "$func"
    done

elif [[ "$this_file" == "$(which zsh)" ]] && [[ "$this_file_name" == "zsh" ]]; then
    echo "\`exec\`-ing $this_file..."
    echo "\`source\`-ing..."
    source "$HOME/.zshrc"
else
    echo "Taking the else...something went wrong."
fi


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ run commands                                                               ║
# ╚════════════════════════════════════════════════════════════════════════════╝

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# scales the display to 2x
# this is only for Parallels on M1 Mac
# if [[ $(uname) == "Linux" ]] && [[ $(echo $HOST) == "ubuntu-linux-22-04-desktop" ]]; then
#     sway output "Virtual-1" scale 2
# fi

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ vi mode                                                                    ║
# ╚════════════════════════════════════════════════════════════════════════════╝

bindkey -v
export KEYTIMEOUT=1

# places the vi mode to the left
# https://stackoverflow.com/questions/3622943/zsh-vi-mode-status-line
# function zle-line-init zle-keymap-select {
#     RPS1="${${KEYMAP/vicmd/-- NORMAL --}/(main|viins)/-- INSERT --}"
#     RPS2=$RPS1
#     zle reset-prompt
# }
# zle -N zle-line-init
# zle -N zle-keymap-select

# Changes cursor depending on vi mode
# i-beam: INSERT mode; block: NORMAL mode
# https://thevaluable.dev/zsh-install-configure-mouseless/
function cursor_mode {
    # See https://ttssh2.osdn.jp/manual/4/en/usage/tips/vim.html for cursor shapes
    cursor_block='\e[2 q'
    cursor_beam='\e[6 q'

    function zle-keymap-select {
        if [[ ${KEYMAP} == vicmd ]] ||
            [[ $1 = 'block' ]]; then
            echo -ne $cursor_block
        elif [[ ${KEYMAP} == main ]] ||
            [[ ${KEYMAP} == viins ]] ||
            [[ ${KEYMAP} = '' ]] ||
            [[ $1 = 'beam' ]]; then
            echo -ne $cursor_beam
        fi
    }

    function zle-line-init {
        echo -ne $cursor_beam
    }

    zle -N zle-keymap-select
    zle -N zle-line-init
}
cursor_mode
