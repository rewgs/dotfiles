# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ about this file                                                            ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# .zshrc is for interactive shells. You set options for the interactive shell there with the setopt 
# and unsetopt commands. You can also load shell modules, set your history options, change your 
# prompt, set up zle and completion, et cetera. You also set any variables that are only used in the 
# interactive shell (e.g. $LS_COLORS).


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ basic interactive shell settings                                           ║
# ╚════════════════════════════════════════════════════════════════════════════╝

LS_COLORS="ow=01;93;40:ln=00;35;40:ex=00;31;40:*.mp3=00;32;40:*.wav=00;32;40:*.aif=00;32;40:*.aiff=00;32;40"
export LS_COLORS


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ zsh functions                                                              ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# Sets the directory for user functions
user_zsh_functions="$HOME/dotfiles/zsh/functions"
FPATH="${user_zsh_functions}:$FPATH"

# Autoloads all functions in the user functions directory
# Don't forget that the functions need the .zsh extension removed before they're able to be used
for func in $user_zsh_functions/*; do
    autoload -Uz $func
done

# configures Homebrew autocomplete in zsh; must be done before sourcing oh-my-zsh
if [[ $(uname) == "Darwin" ]]; then
    eval $(/opt/homebrew/bin/brew shellenv)

    FPATH="$(brew --prefix)/share/zsh/site-functions:${FPATH}"

    autoload -Uz compinit
    compinit
fi


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ oh my zsh                                                                  ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# oh my zsh
ZSH_THEME="robbyrussell"
plugins=(
    docker
    git 
    web-search
)

export ZSH="$HOME/.oh-my-zsh"

source $ZSH/oh-my-zsh.sh


# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ misc                                                                       ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

# zsh parameter completion for the dotnet CLI
_dotnet_zsh_complete() 
{
  local completions=("$(dotnet complete "$words")")

  # If the completion list is empty, just continue with filename selection
  if [ -z "$completions" ]
  then
    _arguments '*::arguments: _normal'
    return
  fi

  # This is not a variable assignment, don't remove spaces!
  _values = "${(ps:\n:)completions}"
}

compdef _dotnet_zsh_complete dotnet

# configures the `fuck` command
eval $(thefuck --alias)

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ aliases                                                                    ║           
# ╚════════════════════════════════════════════════════════════════════════════╝

alias es="exec $SHELL"

# aws
if [[ $(uname) == "Linux" ]]; then
    alias wasabi="aws s3 --profile wasabi"
    alias wsb="aws s3 --profile wasabi"
    alias s3="aws s3 --profile wasabi"
fi

# zshrc
alias z="$EDITOR $HOME/.zshrc"
alias sz="source $HOME/.zshrc"
alias ss="source_shell"

# common commands and funtions
alias c="clear"
if [[ $(uname) == "Darwin" ]] || [[ $(uname) == "Linux" ]]; then
    alias ls="ls_improved"
elif [[ $(uname) == "FreeBSD" ]]; then
    alias ls="ls -al"
fi
alias cls="clear_then_ls_improved"
alias eh="echo 'You are using $HOST'"
alias mkd="mkdir"
alias mv="mv -i"       # prompts before overwriting already-existing file; TODO: make this take multiple arguments
alias rm="rmv"         # aliasing rm to my custom function rmv; TODO: make this take multiple arguments

# neovim
alias v="nvim"
alias nvinit="$EDITOR $HOME/.config/nvim/init.lua"

# docker
if [[ $(uname) == "Linux" ]]; then
    alias docker="sudo docker"
    alias dcls="docker container ls"
    alias ncst="docker start nextcloud-aio-mastercontainer"
    alias ncsp="docker stop nextcloud-aio-mastercontainer"
    alias rm_all_containers=remove_all_docker_containers
fi

# i3 config
if [[ $(uname) == "Linux" ]]; then
    alias i3c="$EDITOR $HOME/dotfiles/i3/config"
fi

# other editors
alias h="hx"    # helix
alias k="kak"   # kakoune
alias n="nano"  # nano

# broot
# TODO: fix this, not currently working
alias b="br" # invokes broot in power-user mode (br)

# git clients
alias g="git-graph"
alias gg="git-igitt"

# git commands
alias gap=git_add_all_and_push_with_commit_message_arg
alias grm=git_commit_readme

# linode
alias sshnextcloud="ssh root@nextcloud.rewgs.com"
alias sshrewgs="ssh root@rewgs.com"

# multipass
if [[ $(uname) == "Darwin" ]]; then
    alias mpls="multipass list"          # lists all multipass VMs
    alias mpsh="multipass shell ubuntu"  # starts and ssh's into main VM
    alias mpst="multipass start ubuntu"  # starts main VM but doesn't connect to it
    alias mpsp="multipass stop ubuntu"   # stops ubuntu VM
    alias snsmpsh="multipass shell sns"
    alias snsmpst="multipass start sns"
    alias snsmpsp="multipass stop sns"
fi

# OrbStack
if [[ $(uname) == "Darwin" ]]; then
    alias archvm="orb -m arch -u rewgs"
    alias ubuntuvm="orb -m ubuntu -u rewgs"
fi

# python
# typically should only be used in an activated venv
alias pipfreeze="pip freeze > requirements.txt"
alias pipinstallreqs="pip install -r requirements.txt"

# pyenv
alias av=activate_venv
alias dv="deactivate"
alias nv=create_new_venv
alias nvhb=create_new_venv_v3.9_with_gui_fix_for_mac

# rustup
alias rustbook="rustup docs --book"
alias rustdocs="rustup doc"

# sed
if [[ $(uname) == "Darwin" ]]; then
    alias sed="gsed"
fi

# ssh
alias dlssh=download_file_from_server_as_name

# tailscale
if [[ $(uname) == "Darwin" ]]; then
    alias tailscale="/Applications/Tailscale.app/Contents/MacOS/Tailscale"
fi

alias tshosts=tailscale_get_magic_dns_hostnames

# tmux
alias t=new_tmux_session_name_optional
alias tls="tmux list-session"
alias ta="tmux attach -t"
alias td="tmux detach"
alias tk="tmux kill-session -t"
alias tq="tmux detach && tmux list-sessions"
alias ts="tmux source-file ~/.tmux.conf"

# yabai/skhd
if [[ $(uname) == "Darwin" ]]; then
    alias yst="brew services start yabai && brew services start skhd"
    alias ysp="brew services stop yabai && brew services stop skhd"
    alias yr="brew services restart yabai && brew services restart skhd"
fi

# xplr
alias x="xplr"

# connections and computers
alias macmini="ssh rewgs@rewgs-mac-mini.local"
alias nas="ssh rewgs@rewgs-nas"

# dotfiles
alias dotfiles="cd $HOME/dotfiles/"
alias dots="cd $HOME/dotfiles/"
alias d="cd $HOME/dotfiles/"
alias dn="cd $HOME/dotfiles/nvim/"

# sns
alias work="cd $HOME/work/"
alias sns="cd $HOME/work/sns/"
alias snsd="cd $HOME/work/sns/development/"
alias snstodo="cd $HOME/work/sns/sns-to-do/ && nvim README.md"

# updates
alias up=update_packages
alias cup=update_packages_and_cargo

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ PATH                                                                       ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# Notes:
# - prepending $PATH: assures that the system looks in this custom path *after* 
#   searching default locations first.
# - appending :$PATH assures that the system looks in this custom path *before* 
#   searching default locations.

# user bin folders
export PATH="$HOME/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/usr/local/bin:$PATH"

# broot
# source $HOME/.config/broot/launcher/bash/br
export PATH="$HOME/.config/broot/launcher/bash:$PATH"

# flutter
export PATH="$HOME/src/flutter/bin:$PATH"

# golang
export GOPATH="$HOME/go"
export PATH="$GOPATH/bin:$PATH"

# nvm
export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# phpenv
# NOTE:
# - .phpenv is symlinked to ~/src/phpenv; repo cloned from github (https://github.com/phpenv/phpenv)
# - In order to use the `phpenv install` command, one must also install php-build 
#   (https://github.com/php-build/php-build); symlink ~/src/php-build to ~/.phpenv/plugins/php-build
export PATH="$HOME/.phpenv/bin:$PATH"
eval "$(phpenv init -)"

# pyenv
# the following must be in both .zshrc (for interactive login shells) and .zprofile (for non-interactive login shells)
# NOTE: .pyenv is symlinked to ~/src/pyenv, repo cloned from github
if [[ $(uname) == "Darwin" ]]; then
    export PYENV_ROOT="$HOME/.pyenv"
    command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(pyenv init -)"
elif [[ $(uname) == "Linux" ]]; then
    # This checks if the current shell is WSL.
    if [[ $(grep -i Microsoft /proc/version) ]]; then
        # On a machine that has pyenv-win installed on the Windows side, as this messes with the 
        # usual $PYENV_ROOT and tries to run `eval "$(pyenv init -)"` in 
        # `/mnt/c/Users/"$(whoami)"/.pyenv` and thus returns a `bad interpreter` error.
        export PYENV_ROOT="/home/"$(whoami)"/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"
    else 
        # The usual works just fine on non-WSL Linux (this is the same as the "Darwin" branch above).
        export PYENV_ROOT="$HOME/.pyenv"
        command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"
    fi
fi

# rust
export PATH="$HOME/.cargo/bin:$PATH"

if [[ $(uname) == "Darwin" ]]; then
    # homebrew
    export PATH="$PATH:/opt/homebrew/bin"
    export PATH="$PATH:/opt/homebrew/sbin"
    export PATH="$PATH:/opt/homebrew/Cellar"
    
    # nim
    export PATH="$PATH:$HOME/.nimble/bin"
    
    # poetry
    export PATH="$PATH:$HOME/.poetry/bin"
# elif [[ $(uname) == "Linux" ]]; then
# else
#     echo "Unsupported operating system!"
fi

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ run commands                                                               ║
# ╚════════════════════════════════════════════════════════════════════════════╝

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# scales the display to 2x
# this is only for Parallels on M1 Mac
# if [[ $(uname) == "Linux" ]] && [[ $(echo $HOST) == "ubuntu-linux-22-04-desktop" ]]; then
#     sway output "Virtual-1" scale 2
# fi
